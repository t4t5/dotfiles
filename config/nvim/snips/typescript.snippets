snippet hardhat_config
import { task } from "hardhat/config"
import "@nomiclabs/hardhat-waffle"

// "npx hardhat accounts"
task("accounts", "Prints the list of accounts", async (_args, hre) => {
	const accounts = await hre.ethers.getSigners()

	for (const account of accounts) {
		console.log(account.address)
	}
})

export default {
	solidity: "0.8.4",
	paths: {
		artifacts: "./src/artifacts",
	},
}
endsnippet

snippet hardhat_test
import { ethers } from "hardhat"
import { expect } from "chai"

describe("MyContract", function () {
	it("should return the username", async function () {
		const MyContract = await ethers.getContractFactory("MyContract")
		const myContract = await MyContract.deploy("tristan")

		expect(await myContract.getName()).to.equal("tristan")
	})
})
endsnippet

snippet hardhat_script
import { ethers } from "hardhat"

async function main() {
  const MyContract = await ethers.getContractFactory("MyContract")
  const myContract = await MyContract.deploy("Hello, Hardhat!")

  await myContract.deployed()

  console.log("Greeter deployed to:", myContract.address)
}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error)
    process.exit(1)
  })
endsnippet

snippet deploy_contract_with_args
import { ethers, waffle } from "hardhat"
import { expect } from "chai"

const { deployContract } = waffle
import ${1:MyContract} from "../src/artifacts/contracts/${1:MyContract}.sol/${1:MyContract}.json"

const accounts = await ethers.getSigners()

const ${2:myContract} = await deployContract(accounts[0], ${1:MyContract}, [
	${3:myArg},
])
endsnippet

snippet hardhat_test_revert_vmexception
await expect(
	shop.purchase(orderNumber, {
		value: ethers.utils.parseEther("1.0"),
	}),
).to.be.revertedWith("wrong amount of Dai sent!")
endsnippet

snippet trpc_query
import { z } from "zod"

import { createRouter } from "trpc/context"

export const ${1:somethingRuter} = createRouter()
  .query("${2:getSomething}", {
    input: z.object({
      userId: z.number(),
    }),
    resolve({ ctx, input }) {
      const { userId } = input

      return null
    },
  })
endsnippet

snippet trpc_test
import { InferMutationInput } from "trpc/types"

import { createTestContext } from "test/db"
import { UserFactory } from "test/factories"

const ctx = createTestContext()

it("${1:description}", async () => {
  const { user } = await UserFactory.create(ctx)

  const caller = ctx.getTrpc({
    userId: user.id,
  })

  const input: InferMutationInput<"${2:trpc_endpoint}"> = {}

  await caller.mutation("${2:trpc_endpoint}", input)
})
endsnippet

snippet l3_action_text
import GmActions from "gql/actions/Gm"

import { createTestContext } from "test/db"
import { UserFactory } from "test/factories"

const ctx = createTestContext()

describe("${1:description}", () => {
  it("${2:test_case}", async () => {
    const { prisma } = ctx

    const { user } = await UserFactory.create(ctx)

    await expect(GmActions.canGmToday(prisma, user.id, 0)).rejects.toThrowError(
      "You can only GM once per day",
    )
  })
})
endsnippet
